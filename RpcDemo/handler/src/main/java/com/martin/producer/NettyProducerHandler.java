package com.martin.producer;import com.martin.entity.ProviderService;import com.martin.entity.Request;import com.martin.entity.Response;import com.martin.zookeeper.RegisterCenter;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.lang.reflect.Method;import java.util.List;/** * 处理服务端的逻辑，handler **/public class NettyProducerHandler extends SimpleChannelInboundHandler<Request> {    private static final Logger logger = LoggerFactory.getLogger(NettyProducerHandler.class);    /**     * 读取完成，发送数据     **/    @Override    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {        ctx.flush();    }    @Override    public void exceptionCaught(ChannelHandlerContext ctx, Throwable throwable) throws Exception {        logger.error("Netty NettyProducerHandler 业务处理出错, e: " + throwable.getMessage());        ctx.close();    }    /**     * 接收消费者发过来的请求，反射调用请求中的方法，将结果写到回复中，发送回去     *     * 1. 从请求中获取服务提供者信息，包含要调用的接口和其对应实现；     * 2. 根据接口名获取本地缓存的对应接口实现列表；     * 3. 在接口实现列表中，选出与请求调用的方法名称相等的服务实现；     * 4. 反射调用服务接口的实现，参数为请求中的参数；     * 5. 根据服务调用结果组装调用返回对象；     * 6. 将服务调用返回对象（结果）回写到消费端。     *     **/    @Override    protected void channelRead0(ChannelHandlerContext ctx, Request request) throws Exception {        // 先判断当前节点是否可写        if (ctx.channel().isWritable()) {            // 从请求里获取服务提供者信息            ProviderService providerService = request.getProviderService();            // 消费请求超时时长            long consumeTimeOut = request.getInvokeTimeout();            // 调用的方法名称            final String methodName = request.getInvokedMethodName();            // 根据方法名称定位到具体一个服务提供者，获取服务接口的名字            String serviceInterface = providerService.getServiceInterface().getName();            // 根据接口名获取本地缓存的对应接口实现列表            List<ProviderService> providerServiceList = RegisterCenter.singleton().getZkProviderServiceMap().get(serviceInterface);            Object result = null;            // 选出与请求调用的方法名称相等的服务实现            ProviderService useProviderService = null;            for (ProviderService service : providerServiceList) {                if (service.getServiceMethod().getName().equals(methodName)) {                    useProviderService = service;                    break;                }            }            if (useProviderService != null) {                Object serviceImpl = useProviderService.getServiceImpl();                // 利用发射发起服务调用                Method method = useProviderService.getServiceMethod();                // 反射调用服务接口的实现，参数为请求中的参数                result = method.invoke(serviceImpl, request.getArgs());            }            // 根据服务调用结果组装调用返回对象            Response response = new Response();            response.setConsumeTimeout(consumeTimeOut);            response.setResponseId(request.getRequestId());            response.setResult(result);            // 将服务调用返回对象回写到消费端            ctx.writeAndFlush(response);            return;        }        logger.error("Netty NettyProducerHandler 在处理业务时，发现 channel 已关闭");    }}