package com.martin.consumer;import com.martin.annotation.RpcInterface;import com.martin.config.ZooKeeperProperty;import com.martin.entity.ConsumerService;import com.martin.entity.ProviderService;import com.martin.zookeeper.IRegisterCenterForConsumer;import com.martin.zookeeper.RegisterCenter;import org.reflections.Reflections;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.BeansException;import org.springframework.beans.factory.InitializingBean;import org.springframework.beans.factory.annotation.Value;import org.springframework.beans.factory.support.DefaultListableBeanFactory;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;import org.springframework.stereotype.Component;import java.util.List;import java.util.Map;import java.util.Set;/** * 客户端，消费者 **/@Componentpublic class ConsumerBootstrap implements ApplicationContextAware, InitializingBean {    private static final Logger logger = LoggerFactory.getLogger(ConsumerBootstrap.class);    /**     * 负载均衡策略     **/    @Value("${consumer.loadBalanceStrategy}")    private String loadBalanceStrategy;    /**     * 消费的超时时间     **/    @Value("${consumer.timeout}")    private int timeout;    /**     * 消费者接口的前缀名     **/    @Value("${consumer.prefix}")    private String interfacePrefix;    /**     * 消费者的 IP     **/    @Value("${consumer.ip}")    private String ip;    /**     * 消费者的端口     **/    @Value("${server.port}")    private int port;    private ApplicationContext applicationContext;    @Override    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {        this.applicationContext = applicationContext;    }    /**     * 初始化 bean 时，执行以下流程     *     * 1. 从注册中心上获取消费者服务列表，缓存到本地     * 2. 初始化 Netty 的 Channel 连接池，根据 providerServcieMap 创建一定数量的 Channel     * 3. 查询，获取标注了 @RpcInterface 的接口列表     * 4. 遍历该接口列表，为每个标注了 @RpcInterface 的接口创建代理对象，注册到 Spring 容器中，同时包装成消费者信息注册到 ZooKeeper 中心     **/    @Override    public void afterPropertiesSet() throws Exception {        // 获取服务注册中心        IRegisterCenterForConsumer iRegisterCenterForConsumer = RegisterCenter.singleton();        // 从 zookeeper 上获取服务，初始化服务提供者列表到本地缓存        iRegisterCenterForConsumer.initProviderMap(ZooKeeperProperty.getRootPath());        // 从本地缓存中获取服务提供者列表        Map<String, List<ProviderService>> providerServcieMap = iRegisterCenterForConsumer.getProviderServiceMapForConsume();        if (providerServcieMap == null || providerServcieMap.isEmpty()) {            logger.error("生产服务列表为空，无法提供服务");            throw new RuntimeException("生产服务列表为空，无法提供服务");        }        // 初始化 Netty 的 channel 连接池        NettyChannelPool nettyChannelPool = NettyChannelPool.nettyChannelPoolInstance();        nettyChannelPool.init(providerServcieMap);        // 查询该服务接口的前缀        Reflections reflections = new Reflections(interfacePrefix);        DefaultListableBeanFactory beanFactory = (DefaultListableBeanFactory) applicationContext.getAutowireCapableBeanFactory();        // 获取标注了 @RpcInterface 的类        Set<Class<?>> typesAnnotatedWith = reflections.getTypesAnnotatedWith(RpcInterface.class);        if (typesAnnotatedWith == null || typesAnnotatedWith.isEmpty()) {            logger.info("没有接口标注 @RpcInterface，无法创建代理对象");            return;        }        // 创建代理对象，将其注册到 Spring 容器中，后续可通过 Spring 应用上下文获取        for (Class<?> clazz : typesAnnotatedWith) {            logger.info("代理对象 {} 注册到 Spring 容器中", clazz.getName());            // 调用反射，为标注了 @RpcInterface 的接口创建代理对象            ConsumerProxy consumerProxy = ConsumerProxy.generate(clazz, timeout, loadBalanceStrategy);            // 将代理对象注册到 Spring 容器中            beanFactory.registerSingleton(clazz.getSimpleName(), consumerProxy.getProxy(clazz));            // 将消费者信息注册到注册中心            ConsumerService consumerService = new ConsumerService();            consumerService.setServiceInterface(clazz);            consumerService.setConumserIp(ip);            consumerService.setPort(port);            iRegisterCenterForConsumer.registerConsumer(consumerService);        }    }}