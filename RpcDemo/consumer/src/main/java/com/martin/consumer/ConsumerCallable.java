package com.martin.consumer;import com.martin.entity.Request;import com.martin.entity.Response;import io.netty.channel.Channel;import io.netty.channel.ChannelFuture;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.net.InetSocketAddress;import java.util.concurrent.Callable;import java.util.concurrent.TimeUnit;/** * 线程池的线程任务 **/public class ConsumerCallable implements Callable<Response> {    private static final Logger logger = LoggerFactory.getLogger(ConsumerCallable.class);    private InetSocketAddress inetSocketAddress;    private Request request;    public static ConsumerCallable generate(InetSocketAddress inetSocketAddress, Request request) {        return new ConsumerCallable(inetSocketAddress, request);    }    private ConsumerCallable(InetSocketAddress inetSocketAddress, Request request) {        this.inetSocketAddress = inetSocketAddress;        this.request = request;    }    /**     * 选择服务器地址，从 Netty 连接池中获取一个 Channel 连接，然后发送消息，接着释放连接     **/    @Override    public Response call() throws Exception {        // 根据本地调用服务提供者的地址，获取对应的 Netty 通道 Channel 队列，获取一个 Channel，        // 在 afterPropertiesSet 中已经为每个服务提供者的 IP 地址初始化一定数量的 Channel        Channel channel = NettyChannelPool.nettyChannelPoolInstance().getChannel(inetSocketAddress,                request.getInvokeTimeout(), TimeUnit.MILLISECONDS);        try {            if (channel != null) {                // 将本次调用的信息写入 Netty 通道，发起异步调用，将请求写出去                ChannelFuture channelFuture = channel.writeAndFlush(request);                // 等待 IO 操作执行完成，如果执行失败，重新抛出失败异常，不响应中断操作                channelFuture.syncUninterruptibly();                // 从返回结果容器中获取返回结果，同时设置等待超时时间为 invokeTimeout                return ResponseHolder.getResponseValue(request.getRequestId(), request.getInvokeTimeout());            }        }  catch (Exception e) {            logger.error("服务调用失败, e: " + e.getCause());        } finally {            // 释放 channel，放回阻塞队列中            NettyChannelPool.nettyChannelPoolInstance().release(inetSocketAddress, channel);        }        return null;    }}