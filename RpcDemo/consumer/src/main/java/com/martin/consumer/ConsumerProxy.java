package com.martin.consumer;import com.martin.entity.ProviderService;import com.martin.entity.Request;import com.martin.entity.Response;import com.martin.ILoadBalance;import com.martin.loadBalanceMap;import com.martin.utils.IdUtil;import com.martin.zookeeper.RegisterCenter;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.net.InetSocketAddress;import java.util.List;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;import java.util.concurrent.TimeUnit;/** * 消费者反射代理类 **/public class ConsumerProxy implements InvocationHandler {    private static final Logger logger = LoggerFactory.getLogger(ConsumerProxy.class);    /**     * 线程池     **/    private static final ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());    /**     * 消费者调用的接口     **/    private Class<?> consumeInterface;    /**     * 负责均衡策略     **/    private String loadBalanceStrategy;    /**     * 消费者调用的超时时间     **/    private int consumeTimeout;    public static ConsumerProxy generate(Class<?> consumeInterface, int consumeTimeout, String loadBalanceStrategy) {        return new ConsumerProxy(consumeInterface, consumeTimeout, loadBalanceStrategy);    }    private ConsumerProxy(Class<?> consumeInterface, int consumeTimeout, String loadBalanceStrategy) {        this.consumeInterface = consumeInterface;        this.consumeTimeout = consumeTimeout;        this.loadBalanceStrategy = loadBalanceStrategy;    }    @SuppressWarnings("unchecked")    public <T> T getProxy(Class<T> interfaceClass){        return (T) Proxy.newProxyInstance(interfaceClass.getClassLoader(), new Class<?>[]{interfaceClass}, this);    }    /**     * 使用 Spring AOP 动态代理，包含反射方法，发起远程 RPC 流程     *     * 1. 根据接口名，从本地缓存中获取生产者的服务实现列表；     * 2. 根据负载均衡策略，从生产者的服务实现列表中，选取一个生产者；     * 3. 构建请求 request，包含请求 id、生产者、超时时间、方法名称、方法的参数信息；     * 4. 线程池根据选定生产者的 IP 和端口，异步发起请求 request，将请求 ID 存到 map 中；     * 5. 收到回复结果，存到 map 中，然后从 map 中根据请求 ID 获取回复，完成异步发送接收过程。     **/    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        // 要调用的接口名        String interfaceName = consumeInterface.getName();        // 根据接口名，获取服务提供者列表，在 afterPropertiesSet() 中已初始化该列表        List<ProviderService> providerServiceList = RegisterCenter.singleton().getProviderServiceMapForConsume().get(interfaceName);        if (providerServiceList == null || providerServiceList.isEmpty()) {            logger.error("生产者的服务列表为空，无法消费");            throw new RuntimeException("生产者的服务列表为空，无法消费");        }        // 选择负载均衡策略        ILoadBalance iLoadBalance = loadBalanceMap.queryBalanceStrategy(loadBalanceStrategy);        ProviderService providerService = iLoadBalance.select(providerServiceList);        // 设置本次调用服务的方法以及接口        providerService.setServiceMethod(method);        providerService.setServiceInterface(consumeInterface);        // 构建请求 request，交由线程池进行发送        final Request request = new Request();        // 设置本次调用的唯一标识        request.setRequestId(IdUtil.generateId());        // 设置本次调用的服务提供者信息，从负载均衡策略选取出来的生产者信息        request.setProviderService(providerService);        // 设置本次调用的超时时间        request.setInvokeTimeout(consumeTimeout);        // 设置本次调用的方法名称        request.setInvokedMethodName(method.getName());        // 设置本次调用的方法参数信息        request.setArgs(args);        // 获取服务提供者的 IP 和端口号        InetSocketAddress inetSocketAddress = new InetSocketAddress(providerService.getServiceIP(),                providerService.getServicePort());        // 线程池发起调用，异步调用，请求 ID 存到 map 中        Future<Response> responseFuture = executor.submit(ConsumerCallable.generate(inetSocketAddress, request));        // 获取调用的返回结果        Response response = responseFuture.get(request.getInvokeTimeout(), TimeUnit.MILLISECONDS);        if (response != null) {            return response.getResult();        }        return null;    }}