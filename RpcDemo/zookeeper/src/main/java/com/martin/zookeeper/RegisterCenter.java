package com.martin.zookeeper;import com.martin.entity.ConsumerService;import com.martin.config.ZooKeeperProperty;import com.martin.entity.ProviderService;import org.apache.commons.lang3.ClassUtils;import org.apache.curator.framework.CuratorFramework;import org.apache.curator.framework.CuratorFrameworkFactory;import org.apache.curator.framework.recipes.cache.PathChildrenCache;import org.apache.curator.framework.recipes.cache.PathChildrenCacheEvent;import org.apache.curator.framework.recipes.cache.PathChildrenCacheListener;import org.apache.curator.retry.ExponentialBackoffRetry;import org.apache.zookeeper.*;import org.apache.zookeeper.data.Stat;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;/** * 注册中心实现 **/public class RegisterCenter implements IRegisterCenterForProvider, IRegisterCenterForConsumer {	private static final Logger logger = LoggerFactory.getLogger(RegisterCenter.class);	/**	 * 服务提供者列表，key 为服务提供者接口，value 为服务提供者的服务方法列表	 **/	private static final Map<String, List<ProviderService>> zkProviderServiceMap = new ConcurrentHashMap<>();	/**	 * 生产者的服务实现列表，用于消费者选取一个服务实现	 */	private static final Map<String, List<ProviderService>> providerServiceMapForConsume = new ConcurrentHashMap<>();	private static RegisterCenter registerCenter = new RegisterCenter();	private RegisterCenter() {	}	public static RegisterCenter singleton() {		return registerCenter;	}	private static volatile CuratorFramework curatorClient;	/**	 * 注册生产者到 zookeeper 流程：	 *	 * 1. 遍历生产者服务列表，将相同接口的多个服务实现放到同一个列表中；	 * 2. 创建 zookeeper 客户端，进行配置；	 * 3. 创建根路径 ROOT_PATH + "/" + APP_KEY，创建 zookeeper 命名空间，当前部署应用 app 命名空间；	 * 4. 遍历不同接口的服务实现哈希表 providerServiceMap，在根路径的基础上，为每个接口创建 zookeeper 路径；	 * 5. 监听注册服务的变化，同时更新数据到本地缓存。	 **/	@Override	public void registerProvider(final List<ProviderService> providerServiceList) {		if (providerServiceList.isEmpty()) {			logger.info("RegisterCenter#registerProvider 注册生产者服务失败，providerServiceList 为空");			return;		}		// 连接 zookeeper，节点格式为: 根路径/服务接口全名/生产者路径/ip:端口，		// 比如 root/com.martin.helloService/provider/localhost:8081		synchronized (RegisterCenter.class) {			connectZk();			// 遍历生产者服务实现列表，解析添加到本地列表 zkProviderServiceMap 中			for (ProviderService providerService : providerServiceList) {				// 获取接口名				String serviceInterface = providerService.getServiceInterface().getName();				// 根据接口名获取接口的实现方法列表，将相同接口的多个服务实现放到同一个列表中				List<ProviderService> zkProviders = zkProviderServiceMap.get(serviceInterface);				if (zkProviders == null || zkProviders.size() == 0) {					zkProviders = new ArrayList<>();				}				// 将该生产者信息添加到对应的接口实现列表中				zkProviders.add(providerService);				// 接口和对应的服务实现列表				zkProviderServiceMap.put(serviceInterface, zkProviders);			}			try {				// 创建永久根节点				createZkNode(ZooKeeperProperty.getRootPath(), CreateMode.PERSISTENT);			} catch (Exception e) {				logger.error("创建根节点 {} 失败: {}", ZooKeeperProperty.getRootPath(), e);			}			// 遍历本地服务实现列表 zkProviderServiceMap，key 为服务提供者接口，value 为服务提供者的服务方法列表，			// 为服务接口创建临时节点，节点格式为: 根路径/服务接口全名/生产者路径/ip:端口			for (Map.Entry<String, List<ProviderService>> entry : zkProviderServiceMap.entrySet()) {				try {					String interfacePath = ZooKeeperProperty.getRootPath() + "/" + entry.getKey();					createZkNode(interfacePath, CreateMode.PERSISTENT);					String providerPath = interfacePath + ZooKeeperProperty.getProviderPath();					createZkNode(providerPath, CreateMode.PERSISTENT);					// 创建当前生产者的节点，包含 IP 地址、端口号					String providerIp = entry.getValue().get(0).getServiceIP();					int providerPort = entry.getValue().get(0).getServicePort();					// 为该生产者 IP 和端口创建临时节点					String currentServiceNode = providerPath + "/" + providerIp + "|" + providerPort;					createZkNode(currentServiceNode, CreateMode.EPHEMERAL);					// 监听服务提供者的变化，当有节点被删除时，则更新本地缓存的服务提供者列表					updataProviderServiceList(providerPath, zkProviderServiceMap);				} catch (Exception e) {					logger.error("RegisterCenter#registerProvider 创建 {} 接口节点失败: {}", entry.getKey(), e);				}			}			logger.info("生产者服务注册到 zookeeper 成功");		}	}	/**	 * 创建 zk 节点	 **/	private void createZkNode(String path, CreateMode createMode) throws Exception {		Stat stat = curatorClient.checkExists().forPath(path);		if (stat == null) {			curatorClient.create().withMode(createMode).forPath(path);		}	}	/**	 * 连接 zookeeper	 **/	private void connectZk() {		if (curatorClient == null) {			curatorClient = CuratorFrameworkFactory.builder()					.connectString(ZooKeeperProperty.getZkService())					.connectionTimeoutMs(ZooKeeperProperty.getZkConnectionTimeout())					.sessionTimeoutMs(ZooKeeperProperty.getZkSessionTimeout())					.retryPolicy(new ExponentialBackoffRetry(ZooKeeperProperty.getBaseSleepTimeMs(),							ZooKeeperProperty.getMaxRetries()))					.build();			curatorClient.start();		}	}	/**	 * 获取生产者服务列表	 **/	@Override	public Map<String, List<ProviderService>> getZkProviderServiceMap() {		return zkProviderServiceMap;	}	/**	 * 消费端获取服务提供者信息	 **/	@Override	public Map<String, List<ProviderService>> getProviderServiceMapForConsume() {		return providerServiceMapForConsume;	}	/**	 * 消费端将消费者信息注册到 zookeeper 对应的节点下	 **/	@Override	public void registerConsumer(ConsumerService consumerService) {		if (consumerService == null) {			return;		}		synchronized (RegisterCenter.class) {			connectZk();			try {				// 消费者，节点格式为: 根路径/服务接口全名/消费者路径/ip:端口，				// 比如 root/com.martin.helloService/consumer/localhost:8081				createZkNode(ZooKeeperProperty.getRootPath(), CreateMode.PERSISTENT);				String interfacePath = ZooKeeperProperty.getRootPath() + "/" + consumerService.getServiceInterface().getName();				createZkNode(interfacePath, CreateMode.PERSISTENT);				String consumerPath = interfacePath + ZooKeeperProperty.getConsumerPath();				createZkNode(consumerPath, CreateMode.PERSISTENT);				String currentServiceNode = consumerPath + "/" + consumerService.getConumserIp() +						"|" + consumerService.getPort();				createZkNode(currentServiceNode, CreateMode.EPHEMERAL);			} catch (Exception e) {				logger.error("创建节点失败: " + e);			}		}	}	/**	 * 将生产者信息缓存到本地，用于消费端从本地获取，在通过负载均衡发起请求调用	 **/	@Override	public void initProviderMap(String path) {		if (providerServiceMapForConsume.isEmpty()) {			providerServiceMapForConsume.putAll(updateZkProviderServiceMap(path));		}	}	/**	 * 发现和更新 zookeeper 上的服务提供者信息列表，即 providerServiceMap	 **/	private Map<String, List<ProviderService>> updateZkProviderServiceMap(String path) {		final Map<String, List<ProviderService>> providerServiceMap = new HashMap<>();		synchronized (RegisterCenter.class) {			// 连接 zookeeper			connectZk();			List<String> providerServiceStrs = null;			try {				// 获取服务接口列表				providerServiceStrs = curatorClient.getChildren().forPath(path);			} catch (Exception e) {				logger.error("zookeeper 获取子节点失败: {}", e.getCause());			}			// zookeeper 下没有子节点，直接返回			if (providerServiceStrs == null || providerServiceStrs.isEmpty()) {				return providerServiceMap;			}			// 遍历接口名，获取类型为生产者的 IP 和端口号			List<String> ipPortPathList = null;			String providerPath = "";			for (String serviceName : providerServiceStrs) {				// 获取生产者				providerPath = path + "/" + serviceName + ZooKeeperProperty.getProviderPath();				try {					ipPortPathList = curatorClient.getChildren().forPath(providerPath);				} catch (Exception e) {					logger.error("zookeeper 获取子节点失败: {}", e.getCause());				}				if (ipPortPathList == null || ipPortPathList.size() == 0) {					continue;				}				for (String ipPortPath : ipPortPathList) {					String[] strings = ipPortPath.split("\\|");					// IP					String providerIp = strings[0];					// 端口号					String providerPort = strings[1];					// 根据接口名获取服务实现列表					List<ProviderService> providerServiceList = providerServiceMap.get(serviceName);					if (providerServiceList == null) {						providerServiceList = new ArrayList<>();					}					// 新建生产者服务类					ProviderService providerService = new ProviderService();					providerService.setServiceIP(providerIp);					providerService.setServicePort(Integer.valueOf(providerPort));					try {						providerService.setServiceInterface(ClassUtils.getClass(serviceName));					} catch (ClassNotFoundException e) {						logger.error("找不到该类: {}", e.getCause());					}					// 添加到服务实现的列表中					providerServiceList.add(providerService);					// 更新 providerServiceMap					providerServiceMap.put(serviceName, providerServiceList);				}			}			// 监听服务提供者的变化，当有节点被删除时，则更新本地缓存的服务提供者列表			updataProviderServiceList(providerPath, providerServiceMapForConsume);		}		return providerServiceMap;	}	/**	 * 监听服务提供者的变化，当有节点被删除时，则更新本地缓存的服务提供者列表	 **/	private void updataProviderServiceList(String providerPath, Map<String, List<ProviderService>> map){		PathChildrenCache pathChildrenCache = new PathChildrenCache(curatorClient, providerPath, true);		try {			pathChildrenCache.start();		} catch (Exception e) {			logger.error("监听启动失败: {}", e.getCause());		}		pathChildrenCache.getListenable().addListener(new PathChildrenCacheListener() {			@Override			public void childEvent(CuratorFramework curatorFramework, PathChildrenCacheEvent event) throws Exception {				// 监听节点被删除，则在本地缓存中去掉该节点				if (event.getData() != null && event.getType() == PathChildrenCacheEvent.Type.CHILD_REMOVED) {					// 路径，比如 "/root/com.martin.api.helloService/provider/localhost|8081					String[] paths = event.getData().getPath().split("/");					// 获取最后一个路径为 IP|端口					String removeIp = paths[paths.length - 1].split("\\|")[0];					// 服务接口作为 map 的 key					String serviceInterface = paths[2];					logger.info("删去的 IP 地址: {}，服务接口为: {}", removeIp, serviceInterface);					// 从 map 中移除被删除的节点 IP					List<ProviderService> serviceList = map.get(serviceInterface);					if (serviceList != null) {						for (ProviderService providerService : serviceList) {							if (providerService.getServiceIP().equals(removeIp)) {								serviceList.remove(providerService);								break;							}						}					}				}			}		});	}}